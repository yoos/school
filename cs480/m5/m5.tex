\documentclass[12pt,letterpaper]{article}
\usepackage[margin=1in]{geometry}
\usepackage{fancyhdr}
\usepackage[utf8]{inputenc}
\usepackage{palatino}
\usepackage{microtype}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{lastpage}
\usepackage[hang,small,margin=1in]{caption}
\usepackage{titlesec}
\usepackage{pdfpages}

\renewcommand{\headrulewidth}{0pt}
\fancyfoot{}
\fancyfoot[C]{\sffamily Page \thepage\ of \pageref{LastPage}}
\pagestyle{fancy}

\titleformat{\section}{\bfseries\MakeUppercase}{\arabic{\thesection}}{1em}{}
\titleformat{\subsection}{\bfseries}{\arabic{\thesection}.\arabic{\thesubsection}}{1em}{}
\titleformat{\subsubsection}{\itshape}{\arabic{\thesection}.\arabic{\thesubsection}.\arabic{\thesubsubsection}}{1em}{}

\setlength{\parindent}{0cm}
\setlength{\parskip}{1em}

\captionsetup[figure]{labelfont=it, font=it}
\captionsetup[table]{labelfont={it,sc}, font={it,sc}}

\hypersetup{colorlinks, linkcolor = black, citecolor = black, urlcolor = black}
\urlstyle{same}



\begin{document}

\fancyfoot{}
\begin{center}
    \hfill \\
    \vspace{4in}
    {\bf\Huge CS480 Milestone \#5 \\}
    \vspace{2in}
    {\Large Soo-Hyun Yoo \\ March 18, 2015}
\end{center}

\newpage
\fancyfoot[C]{\sffamily Page \thepage\ of \pageref{LastPage}}

\section*{Formal Definition}

\subsection*{Loops and Variables/Local Values}

The formal definition for this milestone is similar to that in the previous
milestone in that we recursively pop items off the symbol tree generated by the
syntax parser and place the appropriate gforth code on a stack. Due to the more
irregular nature of gforth syntax compared to that of IBTL, the code to handle
statements cannot be a catch-all conditional as it was for processing
constants. Nevertheless, the overall algorithm is the same:

\begin{verbatim}
def sem-parse(parse-tree):
    if parse-tree.type is token:
        return parse-tree
    else:
        op = parse-tree.pop()
        stack.add(ibtl-to-gforth(parse-tree))
\end{verbatim}

Variable scope is assumed to be global and persistent for simplicity.

Variable value referencing was not implemented due to time constraints, though
the production could be as simple as pushing on the gforth {\tt @} operator
where needed.

As with the rest of the semantic parser, we can assume the input is
well-formed, as the syntax parser will have thrown an error otherwise.

\section*{Specification}

This milestone builds on the previous one by implementing the rest of the
compiler, namely variable assignment and loop handling. The existing
conditional statements that handle constants and their operators will be
extended to handle variables and loops.

\section*{Processing}

The semantic parser was updated to recursively generate the gforth code rather
than using a global stack. The return type was passed up the chain along with
the gforth code as a list, similar to how tokens are handled by the rest of the
compiler as a type-string tuple.

The top-level call to the semantics parser flattens the resulting gforth tree,
and it is this that serves as the stack.

\section*{Testing Requirement}

Again, similarly to the constants milestone, I made short, simple test cases
for all loop and variable assignment operators. The simplicity of each test
case allows for manual verification of test results. The test cases are grouped
by their expected result (success/failure) and the gforth code is output to
a separate directory named {\tt out}.

\section*{Retrospective}

This time, the parser did require the crazy jumble of conditionals I initially
suspected when starting Milestone 4. IBTL's syntax is much more regular, where
parentheses delimit different parts of the code and everything is in prefix
notation. Gforth, however, sometimes uses prefix notation (e.g., when creating
variables) and swaps the order of certain operands in an irregular, if not
counterintuitive, manner. This discrepancy required me to handle them
individually, which does not look as pretty.

This has been my first Common Lisp project. After 10 weeks of using it, I have
come to (really) appreciate its syntactical simplicity. As everything is
a list, code and data representation is coherent and easy to understand, and it
is sometimes even possible to guess the syntax of new functions before
searching documentation. Although picking up the pattern early on was
a challenge and is a major reason for my rather slow progress, it has been
a pleasant experience.

\end{document}
